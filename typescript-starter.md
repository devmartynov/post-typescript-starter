# Typescript. Введение.

И так, давайте поговорим о том, как подключить ts в ваш проект.
Во-первых вам необходимо установить npm пакет typescript. После того, как мы установим этом пакет,
нам будет доступна команда tsc. Чтобы скомпилировать ts файл в js, нужно ввести команду: tsc fileName.ts.
ts выполнить проверку типов, удалит их и сгенерирует js файл.

Во время своей работы компилятор ts опирается на tsconfig.json - конфиг файл, который содержит конфигурацию
для компиляции ts, а также пару глобальных настроек вашего проекта. Интересное замечание, что мы можем
использовать несколько таких tsconfig.json файл в одном проекте, например для того чтобы установить 
разные найстройки компиляции для разных директорий вашего проекта. Для webpack есть соответствующие 
плагины для компиляции ts в js. Не будем долго останавливаться на этом моменте,
и пойдем дальше. Описание всех настроек можно найти на [официальном сайте typescript](https://www.typescriptlang.org/docs/handbook/compiler-options.html).

## Синтаксис объявления типов переменных. Базовые типы.

Начнем с синтаксиса: он очень прост. Для объявления типа переменой вам необходимо поставить двоеточие, после
которого указать тип. Одновременно с этим познакомимся с тремя примитивными типами `string, number, boolean`:

Пример:

```typescript
const foo: string = 'foo';
const bar: number = 1;
const isCar: boolean = true;
```

Тем самым вы говорите TS, что эта перменная типа number. С этого момента и в дальнейшем этой переменной вы сможете присвоить
только значения number, а ваша ваша программа, которая использует эту переменную, будет обрабатывать ее так, как будто 
эта переменная имеет тип number.

Давай рассмотрим простой пример:

Пример:

```javascript
const add = (arg1, arg2) => console.log(arg1 + arg2);
```

Вы, наверняка, знаете, что JS - это язык в котором объекты и переменные могут быть переопределены в любой момент.

Здесь мы видим функцию, которая принимает на вход два аргумента и выводим в консоль их сумму.
Если в качестве одного аргумента мы прокинем строку, а не число, то получится не совсем то, что мы хотели
бы получить.

Теперь давайте объявим типы для этих аргуметов:

```typescript
const add = (arg1: number, arg2: number) => console.log(arg1 + arg2);
```

Теперь, если мы будем вызывать функцию `add('14', 6)` и одним из аргументов будет строка, то компилятор сообщит вам, что
не может использовать значение типа string там, где ожидается number. Но при этом `js` файл будет сгенерирован.

Кроме этого мы можем объявить и тип возвращаемого значения функции.

Пример:
```typescript
    const add = (arg1: number, arg2: number): number => arg1 + arg2;
```

Для того, чтобы показать, что какой-то параметр функции необязательный, используется символ вопроса:

Пример:
```typescript
const add = (arg1: number, arg2?: number): number => arg1 + arg2;
```

Параметры поумолчанию задаются следующим способом:

Пример:
```typescript
const add = (arg1: number, arg2?: number = 3): number => arg1 + arg2;
```

Одной из осебенностей TS явялется то, что для определения типа переменной он использует технику, которая называется "inferred typing". Что она из
себя представляет? TS сделает предположение о типе переменной на основании ее первого присваивания и в дальнейшем будет
считать, что эта перменная именного такого типа.

Пример:

```typescript
const string = 'string';
const sum: number = string + 3; // error: Type 'string' is not assignable to type 'number'
```

TS использует "Утиную типизацию", которая звучит примерно так: если что-то выглядит как утра, крякает как утка, то вероятнее
всего это и есть утка. Другими словами: если объект имеет тот же набор свойств, что и другой объект, то он считается
того же типа.

Пример:

```typescript
let complexType = {id: 1, name: 'name'};
complexType = {name: 'dfd'} // error: Assigned expression type {name: string} is not assignable to type {id: number, name: string}
```

### Тип Array
Кроме столь примитивных типов как `string, number, boolean`, TS предоставляет нам и другой тип `Array`.

Переменная типа `Array` просто помечается как `[]`, кроме этого массивы могут быть строго типизированы для 
хранения определенного типа данных.

Пример:

```typescript
    const arr: [] = [];
    const stronglyTypedArray: string[] = ['1', '2'];
```

### Тип Tuple
Сразу стоит сказать про еще один тип - `Tuple(Кортеж)`.
Кортеж позволяет вам выразить массив, в котором известно количество элементов, и при этом не обязательно эти элементы
имеют одинаковый тип.

Пример:

```typescript
    const array: [string, number] = ['1', 2];
```

### Тип Any
Следующий тип, который мы рассмотрим - тип `Any`.
Хоть и разработчики TS говорят, что ваш JS это валидный TS, на деле вы сталкиваетесь с большим количеством мелких правок.

Пример:

```javascript
    let complexType = {id: 1, name: 'name'};
    complexType = {id: 2}  // Валидный JS код
```

Но как мы рассмотрели ранее этот код уже не валидный TS.
Для таких случаев, когда мы умышленно меняем структуру переменной в TS предусмотрен тип `Any`, который по сути говорит, что
переменная может быть любого типа и тем самым убивает строгую типизацию.

Пример:

```typescript
    let complexType: any = {id: 1, name: 'name'};
    complexType = {id: 2}  // Валидный TS код
```

### Тип Enum
Еще один тип - заимствованный у таких языков как С#, C++, Java - тип `Enum`.
С помощью `Enum` вы можете задать более понятные имена для числовых и строковых значений.

Пример:
```typescript
    enum Direction {
        Up = 1,
        Down,
        Left,
        Right,
    }
    
    enum Direction {
        Up = "UP",
        Down = "DOWN",
        Left = "LEFT",
        Right = "RIGHT",
    }
```

В `yii-steroids` в некоторых случаях мы можем отказаться от наших `Enum` в пользу `Enum` из TS. Но опять же, с этим
есть некоторые проблемы. Например, мы не можем добавлять в `Enum` методы напрямую, для этого можно исползовать всевозможные
"уловки"(костыли).

Пример:
```typescript
    enum Mode {
        X,
        Y
    }
    
    namespace Mode {
        export function toString(mode: Mode): string {
            return Mode[mode];
        }
    
        export function parse(mode: string): Mode {
            return Mode[mode];
        }
    }
    
    const mode = Mode.X;
    
    const str = Mode.toString(mode);
    
    const m = Mode.parse(str);
```

По сравнению с привычной нам записью `Enum`, в которой мы используем `class`, этот способ выглядит весьма неубедительно.

### Тип Void
Функция, вы все это знаете, может ничего не возвращать, с точки зрения TS это значит, что функция возвращает значение типа `Void`.
Объявлять переменные типа `void` не имеет смысла, т.к. этой переменной мы сможем присвоить только `underfined` либо `null`

Пример:
```typescript
const foo: void = undefined; // valid TS
const bar: void = 1; // error: Initializer type number is not assignable to variable type void
```

### Типы Null и Undefined
Еще два типа это `null` и `undefined`.
Кстати, примитивные типы могут быть как `null` так и `undefined`:

Пример:
```typescript
const foo: string = null;
const bar: number = null;
const car: boolean = null;
```
Если в режиме `--strictNullChecks: true` объявить переменной тип `null` или `undefined`, то такой переменной можно будет присвоить только значение `null` или `undefined` соответственно.

Пример:
```typescript
let foo: undefined = undefined;
let bar: null = null;
```

### Тип Never
Слудуюищй тип: `Never`.
Как говористя в документации: Тип `Never` представляет тип, значение которого никогда не наступает.
Например, если у нас есть функция, которая всегда бросает исключения или выход из которой никогда не происходит(бесконечный цикл),
то такая функция возвращает тип `Never`.

Пример:
```typescript
const error = (message: string): never => {
    throw new Error(message);
}

const infiniteLoop = (): never => {
    while (true) {
        ...
    }
}
```

### Тип Object
Тип `Object` представляет собой НЕпримитивный тип, т.е. все то, что НЕ является `string`, `number`, `boolean`, `symbol`, `null`, `underfined`.

Пример:

```typescript
declare const create = (o: object | null): void;

create({ prop: 0 }); // ok
create(null); // ok

create(42); // error
create('string'); // error
create(false); // error
create(undefined); // error
```

## Более продвинутые типы
### Тип Union
TS дает нам возможность выразить тип как комбинацию двух или более типов, используя символ `|`. Т.е. мы говорим, что 
наша переменная может содержать как строку так и число.

Пример:
```typescript
const foo: string | number;
```

Опять же, не все так просто, рассмотрим на примере. Вернемся к нашей функции `add`. И скажем, что каждый ее аргумент
может быть как числом, так и строкой. При этом воспользуемся так называемым `type alias`.

Пример:
```typescript
type stringOrNumber = string | number;
const add(arg1: stringOrNumber, arg2: stringOrNumber) => arg1 + arg2; //  Operator '+' cannot be applied to types 'ReactText' and 'ReactText'
```
TODO: Дописать





