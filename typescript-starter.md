# Typescript. Начало.

И так, давайте поговорим о том, как подключить ts в ваш проект.
Во-первых вам необходимо установить npm пакет typescript. После того, как мы установим этом пакет,
нам будет доступна команда tsc. Чтобы скомпилировать ts файл в js, нужно ввести команду: tsc fileName.ts.
ts выполнить проверку типов, удалит их и сгенерирует js файл.

Во время своей работы компилятор ts опирается на tsconfig.json - конфиг файл, который содержит конфигурацию
для компиляции ts, а также пару глобальных настроек вашего проекта. Интересное замечание, что мы можем
использовать несколько таких tsconfig.json файл в одном проекте, например для того чтобы установить 
разные найстройки компиляции для разных директорий вашего проекта. Для webpack есть соответствующие 
плагины для компиляции ts в js. Не будем долго останавливаться на этом моменте,
и пойдем дальше. Описание всех настроек можно найти на [официальном сайте typescript](https://www.typescriptlang.org/docs/handbook/compiler-options.html).

## Перейдем ко второй теме: Синтаксис объявления типов переменных Базовые типы.

Начнем с синтаксиса: он очень прост. Для объявления типа переменой вам необходимо поставить двоеточие, после
которого указать тип. Одновременно с этим познакомимся с тремя примитивными типами:

Пример:

```typescript
const foo: string = 'foo';
const bar: number = 1;
const isCar: boolean = true;
```

Тем самым вы говорите TS, что эта перменная типа number. С этого момента и в дальнейшем этой переменной вы сможете присвоить
только значения number, а ваша ваша программа, которая использует эту переменную, будет обрабатывать ее так, как будто 
эта переменная имеет тип number.

Давай рассмотрим простой пример:

Пример:

```javascript
const add = (arg1, arg2) => console.log(arg1 + arg2);
```

Вы, наверняка, знаете, что JS - это язык в котором объекты и переменные могут быть переопределены в любой момент.

Здесь мы видим функцию, которая принимает на вход два аргумента и выводим в консоль их сумму.
Если в качестве одного аргумента мы прокинем строку, а не число, то получится не совсем то, что мы хотели
бы получить.

Теперь давайте объявим типы для этиъ аргуметов:

```typescript
const add = (arg1: number, arg2: number) => console.log(arg1 + arg2);
```

Теперь, если мы будем вызывать функцию `add('14', 6)` и одним из аргументов будет строка, то компилятор сообщит вам, что
не может использовать значение типа string там, где ожидается number. Но при этом js файл будет сгенерирован.

Одной из осебенностей TS явялется то, что для определения типа он использует технику, которая называется "inferred typing". Что она из
себя представляет? TS сделает предположение о типе переменной на основании ее первого присваивания и в дальнейшем будет
считать, что эта перменная именного такого типа.

Пример:

```typescript
const string = 'string';
const sum: number = string + 3; // error: Type 'string' is not assignable to type 'number'
```

TS использует "Утиную типизацию", которая звучит примерно так: если это выглядит как утра, крякает как утка, то вероятнее
всего это и есть утка. Другими словами: если объект имеет тот же набор свойств, что и другой объект, то они считаются
того же типа.

Пример:

```typescript
let complexType = {id: 1, name: 'name'};
complexType = {name: 'dfd'} // error: Assigned expression type {name: string} is not assignable to type {id: number, name: string}
```

## Тип Array
Кроме столь примитивных типов как string, number, boolean, TS предоставляет нам и другой тип Array.

Переменная типа `Array` просто помечается как `[]`, кроме этого массивы могут быть строго типизированы для 
хранения определенного типа данных.

Пример:

```typescript
    const arr: [] = [];
    const stronglyTypedArray: string[] = ['1', '2'];
```

## Тип Any
Следующий тип, который мы рассмотрим - тип any.
Хоть и разработчики TS говорят, что ваш JS это валидный TS, на деле вы сталкиваетесь с большим количеством мелких правок.

Пример:

```javascript
    let complexType = {id: 1, name: 'name'};
    complexType = {id: 2}  // Валидный JS код
```

Но как мы рассмотрели ранее этот код уже не валидный TS.
Для таких случаев, когда мы умышленно меняем структуру переменной в TS предусотрен тип any, который по сути говорит, что
переменная может быть любого типа и тем самым убивает строгую типизацию.

Пример:

```typescript
    let complexType: any = {id: 1, name: 'name'};
    complexType = {id: 2}  // Валидный TS код
```

## Тип Tuple
Сразу стоит сказать про еще один тип - Кортеж(Tuple).
Кортеж позволяет вам выразить массив, в котором известно количество элементов, и при этом не обязательно эти элементы
имеют одинаковый тип.

Пример:

```typescript
    const array: [string, number] = ['1', 2];
```

## Тип Enum
Еще один тип - как выяснилось заимствованный у таких языков как С#, C++, Java - тип Enum.
С помощью енамов вы можете задать более понятные имена для числовых значений. К сожалению, к тем енамом, которые мы 
используем в `yii-steroid` они в большенстве случаев не применимы, т.к. чаще всего в енаме мы задаем имена нечисловым значениям.

Ранее мы объявляли только типы аргументов функции, но мы можем объявить и тип возвращаемого значения функции.

Пример:
```typescript
    const add = (arg1: number, arg2: number): number => arg1 + arg2;
```

## Тип Void
Помимо этого, функция может ничего не возвращать, с точки зрения TS это значит, что функция возвращает значение типа `void`.
Объявлять переменные типа `void` не имеет смысла, т.к. этой переменной мы сможем присвоить только `underfined` либо `null`

Пример:
```typescript
const foo: void = undefined; // valid TS
const bar: void = 1; // error: Initializer type number is not assignable to variable type void
```

Для того, чтобы показать, что какой-то параметр функции необязательный, используется символ вопроса:

Пример:
```typescript
const add = (arg1: number, arg2?: number): number => arg1 + arg2;
```

Параметры поумолчанию задаются следующим способом:

Пример:
```typescript
const add = (arg1: number, arg2?: number = 3): number => arg1 + arg2;
```

## Типы null и undefined
Еще два типа это `null` и `undefined`.
Примитивные типы могут быть `null` и `undefined`:
Пример:
```typescript
const foo: string = null;
const bar: number = null;
const car: boolean = null;
```
Но если в режиме `--strictNullChecks: true` объявить переменной тип `null` или `undefined`, то такой переменной можно будет присвоить только значение `null` или `undefined` соответственно.

Пример:
```typescript
let foo: undefined = undefined;
let bar: null = null;
```

## Типы never
Слудуюищй тип: `never`.
Как говористя в документации: Тип never представляет тип, значение которого никогда не наступает. 
Например, never является типом, который возвращает функция, которая всегда бросает исключения или выход из которой 
никогда не происходит (например бесконечный цикл)

Пример:
```typescript
const error = (message: string): never => {
    throw new Error(message);
}

const infiniteLoop = (): never => {
    while (true) {
        ...
    }
}
```

## Типы object
Тип `object` представляет собой НЕ примитивный тип, т.е. все что НЕ является `string`, `number`, `boolean`, `symbol`, `null`, `underfined`.

Пример:
```typescript
declare const create = (o: object | null): void;

create({ prop: 0 }); // OK
create(null); // OK

create(42); // Error
create('string'); // Error
create(false); // Error
create(undefined); // Error
```

## Более продвинутые типы
## Тип Union
TS дает нам возможность выразить тип как комбинацию двух или более типов, используя символ `|`. Т.е. мы говорим, что 
наша переменная может содержать как строку так и число.

Пример:
```typescript
const foo: string | number;
```

Но с этим есть некоторые проблемы, рассмотрим на примере. Вернемся к нашей функции `add`. И скажем, что каждый ее аргумент
может быть как числом, так и строкой. При этом воспользуемся так называемым `type alias`.

Пример:
```typescript
type stringOrNumber = string | number;
const add(arg1: stringOrNumber, arg2: stringOrNumber) => arg1 + arg2; //  Operator '+' cannot be applied to types 'ReactText' and 'ReactText'
```
TODO: Дописать



